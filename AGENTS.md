## 1. Project Overview

This repo contains a small demo web app that tells air travelers **when they should leave for the airport** to comfortably make a specific flight, without wasting an extra hour at the gate. The app focuses on **departures only** (home/work → airport gate).

The goal is to support a hackathon/venture-track pitch: we want a **clean, believable user flow** from “I have a flight” to “I know exactly when to leave,” using **mocked data only** (no real flight or traffic APIs). The tech stack is **Next.js (App Router) + TypeScript + shadcn/ui + Tailwind CSS**.

## 2. Primary Goals (for this demo)

- Deliver a **clear, end-to-end user flow**: from selecting a flight and origin to seeing a recommended leave time and a simple explanation.
- Prioritize **UI clarity and UX smoothness** over perfect architecture or full feature coverage.
- Use **mocked, deterministic data only** (no external APIs, no network calls) so the demo is stable and predictable.
- Showcase **Next.js App Router + shad**

## 3. Non-Goals / Out of Scope

- No real-time integrations:
  - **No live flight status APIs**
  - **No live traffic APIs**
  - **No backend database or external services**
- No user accounts, authentication, or persistence beyond in-memory state.
- No complex state management libraries (Redux, etc.); simple React/Next patterns are enough.
- No full design system build-out beyond **shadcn/ui** and basic Tailwind utilities.
- No production concerns like SEO, analytics, i18n, or accessibility audits beyond reasonable defaults.
- No support for arrivals (gate → curb) or multi-day trip management in this demo.
- Do not create custom “shadcn-like” primitives under `@/components/ui/*`. If a component is in that folder, it must be generated by shadcn/ui.

## 4. Tech Stack & Libraries

- **Framework:** Next.js with the **App Router** (`app/` directory), not the Pages Router.
- **Language:** TypeScript preferred for all components and utilities.
- **UI Library:** **shadcn/ui** components as the primary UI building blocks.
- **Styling:** Tailwind CSS for layout and utility styling, following shadcn defaults.
- **Rendering model:**
  - Use **Server Components** for pages and non-interactive layout where possible.
  - Use **Client Components** only where interactivity is required (forms, sliders, modals).
- **Routing:** Next.js file-based routing via `app/` with simple, shallow route structure (no deep nesting unless clearly justified).
- **Data:** All data is mocked locally in the repo (TypeScript modules / JSON files) and imported directly; no `fetch` calls to external URLs.
- Use `npm` for all dependency and script commands (no yarn/pnpm).
- **UI Library:** **shadcn/ui** components as the primary UI building blocks.
  - shadcn/ui is initialized in this project.
  - Components under `@/components/ui/*` must be the official shadcn-generated components (via `npx shadcn-ui add`), not hand-written lookalikes.


## 5. MCP Tools Available (for Codex)

Codex has several MCP tools enabled for this project. These should be used to speed up development, not to add extra complexity.

### context7

- Purpose: quickly look up **library documentation** and resolve library IDs instead of guessing APIs or types.
- Use it for:
  - Checking how to use specific Next.js, React, or other library functions.
  - Verifying options/props for UI or utility libraries.
- Do **not** rely on this to introduce new heavy dependencies unless clearly justified.

### shadcn

- Purpose: help with **shadcn/ui** component selection and integration.
- Use it for:
  - Finding which shadcn component matches a design need.
  - Getting the correct `npx shadcn add ...` commands and example usage.
- Rules:
  - When you need a new UI primitive (button, card, input, select, slider, badge, dialog, etc.), **use `npx shadcn add`** to generate it.
  - Do **not** hand-roll custom components under `@/components/ui/*` that “mimic” shadcn. Those paths are reserved for official shadcn UI components only.

## 6. Core User Flow

The main flow we care about is **a single, simple path from “I have a flight” to “I know when to leave.”** Codex should optimize for this flow:

1. User lands on the **Planner** screen (`/`).
   - They see fields to choose where they are leaving from, which flight they are taking, and a couple of simple options (checked bag, priority security, domestic/international, risk preference).
2. User taps to **select a flight**.
   - They go to a simple **Select Flight** view (separate route or modal) with mocked flights.
   - They pick one flight and are returned to the Planner with that flight filled in.
3. Back on the Planner, user optionally adjusts settings (origin, options, risk slider) and clicks **“Calculate leave time”**.
4. User clicks **“Calculate leave time”** on the Planner.
   - The app navigates to a dedicated **Result** screen at `/result`, passing enough info (flight id + options) to recompute the plan.
   - The Result screen shows:
     - One big answer: “Leave at HH:MM”.
     - A vertical **timeline** of the whole trip (home → curb → check-in → security → gate → boarding).
     - Short explanation and risk indicator.

5. User may tweak risk or options and recalculate, or just close the app / imagine acting on the recommendation.

All pages and components should support this flow first. Any additional features are secondary to making this feel smooth, obvious, and reliable in the demo.

## 7. Screens / Routes Needed

The app should stay small and route-light. Prefer a shallow structure with a few clear screens:

### `/` – Planner Screen (Home)

This is the main entry point and primary UI.

- Purpose: let the user configure their trip and request a recommendation.
- Key UI elements:
    - **Origin / Leaving from**:
    - Input for where the user is leaving from.
    - Behaves like a **mock autocomplete**:
      - There is a small static list of realistic origins (e.g. “Home — 200 W Madison St, Chicago, IL”, “Office — 1 N State St, Chicago, IL”, “Downtown hotel — …”, etc.).
      - As the user types, we filter this list by case-insensitive substring match on label or address.
      - Only matching items are shown in a dropdown using a shadcn combobox/command-style UI.
      - If there are no matches (for query length ≥ 2), either hide the dropdown or show a simple “No suggestions in this demo” row, and allow the user’s free-form text to remain.
    - Selecting an origin stores its label (and optionally an internal id) in `TripOptions`.
  - **Travel mode selector**:
    - Simple select: `Car`, `Taxi`, `Rideshare`, `Public transit`.
    - Internally, this just chooses different mocked travel times.
  - **Flight selector**:
    - A button or input that opens the “Select Flight” view (below).
    - Once selected, shows a compact summary: airline, flight number, departure time, terminal.
  - **Trip options**:
    - Toggle or select for `Checked bag` vs `No checked bag`.
    - Toggle for `Priority / Fast track` vs `Standard`.
    - `Domestic` vs `International` (can be inferred from mocked flight data, but user override is fine).
  - **Risk preference control**:
    - Slider or segmented control: `Less waiting` / `Balanced` / `Very safe`.
  - **Primary action**:
    - Button: **“Calculate leave time”**.
- Behavior:
  - On submit, we compute a recommendation using mocked logic and either:
    - Navigate to `/result`, or
    - Show the Result view inline (e.g., below the form).

### `/select-flight` – Select Flight Screen (or modal)

This can be a dedicated route or a modal/dialog on top of `/`.

- Purpose: choose a mocked flight for today in a way that **feels like real flight search**.
- Key UI elements:
  - **Search input**:
    - Single text field where the user can type either:
      - A flight number (e.g. "UA101", "AA 432"), or
      - A destination city/airport code (e.g. "LAX", "Los Angeles"), or
      - A mix (e.g. "UA LAX").
    - As the user types, we filter the mocked flights array in memory (no network calls).
    - Filtering is case-insensitive and should match on:
      - `flightNumber`,
      - airline name/initials,
      - `arrivalAirport` or arrival city label.
  - **(Optional) Time-of-day filter**:
    - Simple segmented control: `All`, `Morning`, `Afternoon`, `Evening`.
    - For MVP, this can just be a visual filter over the same mocked flights array.
  - **List of mocked flights**:
    - Each row shows: airline logo/initials (or simple badge), flight number, route (e.g. "ORD → LAX"), departure time, terminal, and a small `Domestic` / `International` tag.
    - The list reflects the current search filter (and time-of-day filter, if present).
  - **Selecting a flight**:
    - Clicking a row selects that `Flight` and closes the dialog.
    - The chosen `Flight` object is stored in state and shown on the Planner (airline, flight number, departure time, terminal).
- Behavior:
  - All search and filtering happens **client-side** over the mocked `flights` array; there are no API calls.
  - If the search query has no matches (for query length ≥ 2), show a simple "No matching flights in this demo" row.


### `/result` – Recommendation Screen (separate page)

This is a dedicated route. The Planner always navigates here after “Calculate leave time”.

- Purpose: show the recommended leave time and a detailed, step-by-step plan for the trip.
- Navigation:
  - The Planner pushes to `/result` with query params (e.g. `flightId`, `riskPreference`, options).
  - `/result` reconstructs the inputs, calls `getRecommendation`, and renders the result.

- Key UI elements:

  - **Summary card (top)**
    - Big, prominent **“Leave at HH:MM”** text.
    - Subtext summarizing the plan, e.g.:
      - “You’ll reach the gate around 11:45 AM, about 15 minutes before boarding at 12:00 PM.”
    - Small risk pill on the right: `Risk: Low / Medium / High`.

  - **Trip timeline card (main content)**
    - Vertical timeline from “Leave home” to “Boarding starts”.
    - Each node shows:
      - Time (HH:MM).
      - Title (e.g. “Leave home”, “Arrive at airport curb”, “Finish check-in / bag drop”, “Clear security”, “Arrive at gate”, “Boarding starts”).
      - Short description including:
        - Approximate duration for that leg, e.g. “Travel to airport by car (~35 min)”.
        - Why that duration (domestic vs international, checked bag, priority security, etc.).
      - Visually distinguish completed vs upcoming steps if the user recalculates later.
    - Times are derived from `leaveTime`, `boardingTime`, and the `segments` durations in `Recommendation`.

  - **“Running late or stuck?” panel**
    - Small section below the timeline allowing **manual re-evaluation**:
      - Select input: “Where are you now?” with options like:
        - `At home`, `In transit`, `At check-in`, `At security`, `At gate`.
      - Time input: “Current time” (default = browser “now”, editable).
      - Button: **“Recalculate from here”**.
    - Behavior:
      - When the user clicks “Recalculate from here”, treat all earlier steps as completed.
      - Use the current time as the new start time for the selected step.
      - Recompute the remaining steps using the same mocked durations (no external APIs).
      - Update:
        - Gate arrival time,
        - Buffer,
        - Risk level,
        - Timeline (earlier nodes can appear dimmed / completed).

  - **Footer actions**
    - **“Back to planner”** button:
      - Navigates back to `/`, ideally with the previously selected flight and options pre-filled.
    - **“Share plan”** button:
      - For this demo, it can:
        - Open a simple modal with a text summary that could be copied/shared, or
        - Use the Web Share API if available.
      - No backend integration is required; this is a local-only share.

- Constraints:
  - All computations and re-evaluations are done on mocked data in the client or server components.
  - No live location, traffic, or flight status is used in this demo.

> Implementation note for agents: It is acceptable (and possibly simpler) to keep everything under `/` and conditionally render the “Planner” vs “Result” states instead of separate routes. The important part is that the **flow between planning and seeing a recommendation is obvious and smooth**, not the exact routing shape.

## 8. Data Model & Mock Data Strategy

All data must be **local and deterministic**. Do not call external APIs or perform network requests.

### Core entities (conceptual)

- **Flight**
  - `id` (string)
  - `airline` (string)                      // e.g. "United", "American"
  - `flightNumber` (string)                 // e.g. "UA101"
  - `departureAirport` (string, e.g. "ORD")
  - `arrivalAirport` (string, e.g. "LAX")
  - `departureTime` (Date or ISO string)
  - `terminal` (string)
  - `gate` (string, optional)
  - `isInternational` (boolean)
  - (Optional) `arrivalCity` (string, e.g. "Los Angeles")

- **Origin**
  - `id` (string)
  - `label` (string, short name, e.g. "Home", "Office", "Downtown hotel")
  - `address` (string, full realistic-looking address, e.g. "200 W Madison St, Chicago, IL")
  - (Optional) `travelProfileKey` (string) if we ever want to map origins to different mocked travel times.

- **TripOptions**
  - `originLabel` (string, e.g. "Home", "Office", or a short address)
  - `travelMode` (`"car" | "taxi" | "rideshare" | "transit"`)
  - `hasCheckedBag` (boolean)
  - `hasPrioritySecurity` (boolean)
  - `riskPreference` (`"low_wait" | "balanced" | "very_safe"`)

- **Recommendation**
  - `leaveTime` (Date or ISO string)
  - `expectedGateArrivalTime` (Date or ISO string)
  - `boardingTime` (Date or ISO string)
  - `bufferMinutes` (number)
  - `riskLevel` (`"low" | "medium" | "high"`)
  - `segments`: array of `{ label: string; minutes: number }`
    - Examples: `"Travel to airport"`, `"Check-in / bag drop"`, `"Security"`, `"Walk to gate"`, `"Buffer"`.

### Mock data strategy

- Store mocked flights in a simple module, e.g. `data/flights.ts`, exporting an array of `Flight` objects and helper functions to filter them.
- Store any fixed constants (e.g. typical times per airport/flight type) in `data/constants.ts` or similar.
- Implement a pure function in `lib/recommendation.ts`, e.g. `getRecommendation(flight, options): Recommendation`, which:
  - Uses mocked travel times based on `travelMode`.
  - Uses fixed or simple rule-based durations for airport steps.
  - Computes `leaveTime`, `expectedGateArrivalTime`, `bufferMinutes`, `riskLevel`, and `segments`.
- All mocking should be simple and transparent so the UI always has a complete `Recommendation` object to render without error.
- Store mocked origins in `data/origins.ts` as an array of `Origin` objects.
- The Planner’s “Leaving from” field:
  - Imports this origins array.
  - Filters it on each keystroke to provide suggestions, but never shows non-matching items.
  - Falls back to allowing free-form text when there are no matches.

- The `/result` timeline does not need a separate stored entity:
  - It is derived on the fly from `Recommendation.leaveTime`, `Recommendation.boardingTime`, and `Recommendation.segments`.
  - A helper function can convert these into an ordered array of timeline nodes with timestamps and labels for UI use.


## 9. Mock “Business Logic” Rules

The goal is to have a **simple, deterministic function** that turns a `Flight` + `TripOptions` into a `Recommendation` using only mocked values. Do not implement real statistical models; use basic rules and constants.

### High-level behavior

Implement a pure function (e.g. `getRecommendation(flight, options): Recommendation`) that:

1. Computes a **mock boarding time** from the flight’s departure time  
   - Example: `boardingTime = departureTime - 30 minutes` (constant for MVP).

2. Computes **travel to airport** duration from `travelMode`  
   - Example mapping (adjustable constants):
     - `car`: 35 min  
     - `taxi`: 35 min  
     - `rideshare`: 40 min  
     - `transit`: 50 min  

3. Computes **airport process times** from `flight.isInternational`, `hasCheckedBag`, and `hasPrioritySecurity`  
   - Example rule of thumb:
     - Base check-in/bag drop:
       - Domestic + no bags: 0–5 min (use 5 min)
       - Domestic + bags: 15 min
       - International: 25 min
     - Base security:
       - Standard: 25 min
       - Priority: 10–15 min (use 12 min)
     - Walk to gate: fixed 10–15 min (use 10 min)

4. Applies **risk preference buffer**  
   - Map `riskPreference` to extra time:
     - `"low_wait"`: +5 min
     - `"balanced"`: +15 min
     - `"very_safe"`: +30 min

5. Works backwards from boarding time to compute `leaveTime`  
   - `totalProcessMinutes = checkInMinutes + securityMinutes + walkMinutes + bufferMinutes`
   - `arrivalAtAirportCurbTime = boardingTime - totalProcessMinutes`
   - `leaveTime = arrivalAtAirportCurbTime - travelToAirportMinutes`

6. Computes **expectedGateArrivalTime**, **bufferMinutes**, **riskLevel**, and **segments**  
   - `expectedGateArrivalTime = boardingTime - bufferMinutes`
   - `bufferMinutes` is already known from step 4.
   - `riskLevel` can be mapped directly from `riskPreference` for MVP:
     - `"low_wait"` → `"medium"` (more risk)
     - `"balanced"` → `"low"`
     - `"very_safe"` → `"low"` (very conservative)
   - `segments` is an array describing each piece and its minutes:
     - `"Travel to airport"`: travelToAirportMinutes
     - `"Check-in / bag drop"`: checkInMinutes
     - `"Security"`: securityMinutes
     - `"Walk to gate"`: walkMinutes
     - `"Buffer"`: bufferMinutes

### Implementation notes for agents

- Keep all numeric values as simple constants or small lookup tables in a config module (e.g. `data/timeProfiles.ts`), not scattered magic numbers.
- The function should not call `Date.now()` directly in many places; use clear, explicit time arithmetic starting from the flight’s known `departureTi


### Re-evaluation from a checkpoint

- Provide a helper (e.g. `recalculateFromCheckpoint`) that:
  - Accepts the original `flight`, `options`, a `checkpointStep` (e.g. "in_transit", "check_in", "security", "gate"), and a `checkpointTime`.
  - Treats all steps before the checkpoint as completed.
  - Uses `checkpointTime` as the new start time for the checkpoint step.
  - Recomputes the remaining durations and returns an updated `Recommendation` (and thus updated timeline).
- This logic must still be deterministic and use the same mocked durations as the initial plan (no live APIs).


## 10. UI / UX Guidelines

The app should feel **simple, focused, and calm**. The main goal is to make the “when should I leave?” decision obvious, not to impress with visual complexity.

- Use **shadcn/ui** components wherever reasonable:
  - Likely: `Button`, `Input`, `Select`, `Card`, `Slider`, `Badge`, `Label`, `Dialog` (if using a modal for flight selection).
- Layout:
  - Centered or single-column layout on desktop, stacked vertically on mobile.
  - Clear grouping: “Trip setup” (origin, mode, flight, options, risk), then “Result”.
- Text:
  - Short, plain language labels: “Leave at 16:40”, “Checked bag”, “Security fast track”, “Risk: Low”.
  - Avoid jargon like “probabilistic model” or “time distributions” in the UI.
- Feedback:
  - When the user hits “Calculate leave time”, give immediate visual feedback (e.g. show result state, no spinners needed if everything is mocked).
  - If inputs are missing (e.g. no flight selected), show a simple inline message near the “Calculate” button.
- Visual emphasis:
  - The **recommended leave time** should be the most visually prominent element on the Result state.
  - The breakdown and risk indicator should be easy to scan but secondary.
- Styling:
  - Use Tailwind + shadcn defaults; keep color palette minimal (background, primary, subtle accents).
  - Avoid heavy custom CSS; no need for complex animations or transitions for this demo.

---

## 11. Coding Conventions

- Use **TypeScript** for all components, utilities, and data modules.
- Prefer a simple directory structure, for example:
  - `app/` – Next.js routes and layouts.
  - `components/` – Reusable UI components (forms, cards, etc.).
  - `data/` – Mock data and configuration (flights, time profiles).
  - `lib/` – Pure functions (e.g. recommendation logic).
- Components:
  - Use functional React components only.
  - Use **Server Components** by default in `app/`, and switch to **Client Components** only when interactive state is required.
- State management:
  - Use local React state (`useState`, `useReducer`) or props drilling for this small app.
  - Avoid external state libraries (Redux, Zustand, etc.) unless absolutely necessary.
- Imports:
  - Keep imports organized and avoid circular dependencies (UI components should not depend on `app/` routes).
- Formatting:
  - Assume standard Prettier/ESLint defaults; follow idiomatic Next.js + TypeScript style.

---

## 12. How Agents Should Behave

This file guides AI agents (e.g. Codex) when modifying or generating code for this project.

- Always align with the **core user flow** described above; do not introduce new flows or features that distract from it.
- When adding functionality:
  - Prefer the **simplest implementation** that satisfies the UX and mock logic requirements.
  - Reuse existing components and patterns before creating new ones.
- Do not:
  - Add new routes beyond those described without a clear reason.
  - Integrate real APIs, databases, or authentication.
  - Introduce heavy dependencies or complex patterns just for “best practice” if they do not serve this demo.
- Use the **MCP tools** to:
  - Look up library usage (context7).
  - Choose and integrate appropriate shadcn components (shadcn).
  - Optionally, sanity-check UI flows in a browser (playwright), but only if explicitly requested.
- When in doubt between “more abstraction” and “clearer code for a small demo,” choose **clearer, simpler code**.
- If you need a new UI component that exists in the shadcn registry (button, card, input, select, slider, badge, dialog, etc.):
  - Use the official shadcn component (via `npx shadcn-ui add ...`), and then use it.
  - Never substitute “lightweight custom components” that imitate shadcn patterns.

---

## 13. Open Questions / TODOs

These are areas that can be left rough or stubbed for now, but may be revisited:

- Flight search:
  - For MVP, use a simple client-side filter over the mocked flights array based on the search query (flight number, airline, destination city/airport).

- Time realism:
  - Current time constants are arbitrary; improving realism is optional and can be done later by tweaking `data/timeProfiles`.
- Multiple airports and cities:
  - The initial demo can focus on a single departure airport (e.g. ORD) with a few sample flights.
- Persisted preferences:
  - Saving “Home”, “Office”, and default options in local storage is optional; not required for the demo.
- Metrics and logging:
  - No analytics or logging are needed yet; if added, keep them minimal and local.

Agents should treat these as **safe places to simplify or stub** unless explicitly instructed to expand them.


